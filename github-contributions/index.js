function getSourceFromScript(scriptId) {
    const shaderScript = document.getElementById(scriptId);
    if (!shaderScript) {
      throw ("*** Error: unknown script element" + scriptId);
    } 
    const text = shaderScript.text;
    return text;
  }
  
function createShaderFromScript(gl, scriptIds) {
    let shaders = [getSourceFromScript(scriptIds[0]), getSourceFromScript(scriptIds[1])];
    if(shaders.length <= 1) {
        console.warn("shaders text error", shaders);
    }
    const program = twgl.createProgramInfo(gl, shaders);

    return program;
}

function toRaius(a) {
  return a * 180 / Math.PI;
}

const fieldView = toRaius(60);



function makeTexture (gl) {
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  
  {
    const level = 0;
    const internalFormat = gl.R8;
    const width = 7;
    const height = 22;
    const border = 0;
    const format = gl.RED;
    const type = gl.UNSIGNED_BYTE;
    const data = new Uint8Array([
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        // 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        // 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
    ]);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border,
                  format, type, data);

    // set the filtering so we don't need mips
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }

  return texture;
}

function main() {
    const canvas = document.getElementById("happy-life-happy-code");
    const gl = canvas.getContext("webgl2") ||
      canvas.getContext("webgl") ||
      canvas.getContext("experimental-webgl");

    if( !gl ) return console.error("sorry, your browser does't not support webgl now!");
    twgl.setAttributePrefix("a_");
    const programInfo = createShaderFromScript(gl, ["vertex", "frag"]);
    const programInfo1 = createShaderFromScript(gl, ["vertex1", "frag1"]);
    const { program } = programInfo;
    const program1 = programInfo1.program;

    function createCylinders(x, y) {
      let world = twgl.m4.scale(m4.identity(), [0.1, .5, .1]);
      world = twgl.m4.translate(world, [x, .5, y]);
      twgl.setUniforms(programInfo1, {
        u_world: world
      });
      gl.bindVertexArray(cubevao);
      twgl.drawBufferInfo(gl, cubeBuffInfo);
    }

    const cubeBuffInfo = twgl.primitives.createCubeBufferInfo(gl, 1);
    const cubevao = twgl.createVAOFromBufferInfo(gl, programInfo1, cubeBuffInfo);

    const planeBufferInfo = twgl.primitives.createPlaneBufferInfo(gl, 1, 1);
    const planevao = twgl.createVAOFromBufferInfo(gl, programInfo, planeBufferInfo);
    // gl.useProgram(program);
    
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    var t = makeTexture(gl);
    var tick = function(time) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(program);
        const projection = m4.perspective(fieldView, canvas.width / canvas.height, 1, 1000);
        let view = m4.lookAt([Math.cos(time * 0.0001) * 3, 2, Math.sin(time * 0.0001) * 3], [0, 0, 0], [0, 1, 0]);
        view = m4.inverse(view);
        let world = twgl.m4.scale(m4.identity(), [0.7, .1, 2.2]);

        twgl.setUniforms(programInfo, {
          u_projection: projection,
          u_view: view,
          u_world: world,
          u_texture: t
        });

        gl.bindVertexArray(planevao);
        twgl.drawBufferInfo(gl, planeBufferInfo);

        gl.useProgram(program1);

        world = twgl.m4.translate(world, [0, -.51, 0]);

        twgl.setUniforms(programInfo1, {
          u_projection: projection,
          u_view: view,
          u_world: world
        });
        
        gl.bindVertexArray(cubevao);
        twgl.drawBufferInfo(gl, cubeBuffInfo);

        createCylinders(1, 2);
        createCylinders(0, 0);

        window.requestAnimationFrame(tick);

    }

    window.requestAnimationFrame(tick);
}

